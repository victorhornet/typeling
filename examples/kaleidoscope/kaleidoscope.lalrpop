use crate::kaleidoscope::{ast::*, tokens::Token as KaleidoscopeToken};
use std::str::FromStr;
grammar;

pub File: File = {
    <l:@L> <items:Item*> <r:@R> => File::new(items, Span::new(l as u32, r as u32))
}

pub Item: Item = {
    Extern => Item::Extern(<>),
    FunctionDef => Item::Function(<>),
};

Extern: FunctionDecl = {
    <l:@L> EXTERN <name:Ident> "(" ")" <r:@R> => FunctionDecl::new(name, Vec::new(), Span::new(l as u32, r as u32)),
};

FunctionDef: Function = {
    <l:@L> <sig:FunctionSig> <expr:Expr> <r:@R> => Function::new(sig, expr, Span::new(l as u32, r as u32)),
};

FunctionSig: FunctionDecl  = {
    <l:@L> DEF <name:Ident> "(" <args:Ident*> ")" <r:@R> => FunctionDecl::new(name, args, Span::new(l as u32, r as u32)),
};

Ident: Ident = {
    <l:@L> <id:IDENT> <r:@R> => Ident::new(id.as_ident().unwrap(), Span::new(l as u32, r as u32)),
};

Expr: Expr = {
    FunctionCall => Expr::FunctionCall(<>),
    Literal => Expr::Literal(<>),
    Ident => Expr::Ident(<>),
}

FunctionCall: FunctionCall = {
    <l:@L> <name:Ident> "(" <args:Args?> ")" <r:@R> => FunctionCall::new(name, args.unwrap_or_else(|| vec![]), Span::new(l as u32, r as u32)),
};

Args: Vec<Expr> = {
    <Expr> => vec![<>],
    <e:Expr> "," <mut args:Args> => {
        args.insert(0, e);
        args
    },
}

Literal: Literal = {
    <l:@L> <lit:LITERAL> <r:@R> => Literal::new(lit.as_number().unwrap(), Span::new(l as u32, r as u32)),
}

LITERAL: KaleidoscopeToken<'input> = {
    <n:NUM> => KaleidoscopeToken::Number(f64::from_str(n).unwrap()),
}

EXTERN: KaleidoscopeToken<'input> = {
    "extern" => KaleidoscopeToken::Extern,
};
IDENT: KaleidoscopeToken<'input> = {
    ID => KaleidoscopeToken::Identifier(<>),
};

DEF: KaleidoscopeToken<'input> = {
    "def" => KaleidoscopeToken::Def,
};

match {
    "extern",
    "def",
    r"\d+(\.\d+)?" => NUM 
} else {
    r"[\w][\w\d_]*" => ID,
    _
}