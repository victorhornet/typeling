
type Option = Some i64 | None

type List = Node i64 List | Empty


type BinTree = BNode i64 BinTree BinTree | BEmpty


fn insert(x: i64, root: BinTree) -> BinTree {
    return case root {
        BNode (y, left, right) => case x < y {
            0 => BNode (y, left, insert(x, right)),
            _ => BNode (y, insert(x, left), right),
        },
        _ => BNode (x, BEmpty, BEmpty),
    };
}

fn insert_mut(x: i64, root: BinTree) -> i64 {
    case root {
        BNode (y, left, right) => case x < y {
            0 => insert_mut(x, right),
            _ => insert_mut(x, left),
        },
        _ => helper_assign(root, BNode (x, BEmpty, BEmpty)),
    };
    return 0;
}

fn helper_assign(root: BinTree, new_root: BinTree) -> i64 {
    root = new_root;
    return 0;
}

fn get_min(root: BinTree) -> i64 {
    return case root {
        BNode (x, BEmpty, _) => x,
        BNode (_, left, _) => get_min(left),
        _ => 0,
    };
}

fn main() -> i64 {
    return bintree_demo();
}

fn bintree_demo() -> i64 {
    tree := BNode (5, BNode (3, BEmpty, BEmpty), BNode (7, BEmpty, BEmpty));
    tree = insert(4, tree);
    tree = insert(6, tree);
    tree = insert(2, tree);
    return get_min(tree);
}

fn list_demo() -> i64 {    
    list := Node (2, Node (3, Empty)); 
    
    x := head(list);
    printf("x = %lli\n", unwrap_or_default(x));
    y := tail(list);
    z := head(y);
    printf("z = %lli\n", unwrap_or_default(z));

    list = Node(1, list);
    printf("head(list) = %lli\n", unwrap_or_default(head(list)));

    list = append(4, list);

    printf("list[4] = %lli\n", unwrap_or_default(get(4, list))); //unwrap_or_default(get(5, list)) //unwrap_or_default(head(tail(tail(tail(list))))
    
    return 0;
}

fn get(i: i64, l: List) -> Option {
    return case l {
        Node (x, xs) => case i { 0 => Some(x), _ => get(i - 1, xs) },
        _ => None,
    };
}

fn prepend(x: i64, xs: List) -> List {
    return Node (x, xs);
}


fn append(x: i64, xs: List) -> List {
    return case xs {
        Node (y, ys) => Node (y, append(x, ys)),
        _ => Node (x, Empty),
    };
}

fn is_empty(l: List) -> i64 {
    return case l {
        Empty => -1,
        _ => 0,
    };
}

fn head(l: List) -> Option {
    return case l {
        Node (x, _) => Some(x),
        _ => None,
    };
}


fn tail(l: List) -> List {
    return case l {
        Node (_, xs) => xs,
        _ => Empty,
    };
}


fn unwrap_or_default(x: Option) -> i64 {
    return case x {
        Some(i) => i,
        _ => 0,
    };
}

