type Enum = A
          | B i64
          | C a:i64 b:i64  

type Tuple = Tuple i64 i64

type S = S i64 S | E

type List = Nil
          | Cons i64 List

type BinTree = Leaf
             | Node i64 BinTree BinTree

type Loop = Loop i64 Loop | Temp

type OptionalInt = NoneI | SomeI i64
type OptionalTuple = NoneT | SomeT Tuple

fn enums() -> i64 {
    a : Enum =  A;
    b : Enum =  B(1);


    c : Enum =  C(b=20, a=10); // named constructors can be in any order

    d : Enum =  C(10, 20);     // unnamed constructor must be in order 


    x : i64 = c.0;
    y : i64 = c.1;
    z : i64 = x + y;
    z = z + y;

    c = C(a=c.0, b=100);
    return c.0 + c.1;
}

fn list() -> i64 {
    list : List =  Cons(1, Cons(2, Cons(3, Nil)));
    head : List = list.0;
    tail : List = list.1;

    x : i64 = head;
    y : List = tail;
    z : i64 = x + y.0;
    return z;
}

fn tree() -> i64 {
    tree: BinTree =  Node(20, Node(10, Leaf, Leaf), Node(30, Leaf, Leaf));

    left: BinTree = tree.1;
    right: BinTree = tree.2;


    return left.0 + tree.0 + right.0;
}

fn fake_infinite() -> i64 {
    x : Loop =  Loop(1,  Temp);
    x =  Loop(1, x);

    x.0 = 100;

    return x.0;
}

fn test_tags() -> i64 {
    x: Enum =  A;
    y: Enum =  B(1);
    z: Enum =  C(10,20);
    return 0;
}

fn optionals() -> i64 {
    x: OptionalInt = NoneI;
    y: OptionalInt = SomeI(10);
    z: OptionalTuple = SomeT(Tuple(10, 20));
    return y.0;
}


/*fn switch_statement() -> i64 {
    x: Enum =  A;
    y: Enum =  B(1);
    z: Enum =  C(10,20);

    case1: Enum = case x {
        A => return 1,
        B(i) => return i,
        C(a,b) => return a + b,
    };

    //case2: Enum = case x : A => 1 | B(i) => i | C(a,b) => a + b ;


    return z.b;
}*/

fn main() -> i64 {
    z: Enum = C(10,69);
    z.0 = 100;
    return z.0 + z.1;
}




